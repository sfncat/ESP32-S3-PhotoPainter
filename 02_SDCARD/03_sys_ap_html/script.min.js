let ImageSys, InPutButton, SendButton, FileInput, RotateButton;
let modeButtons, tips; 
let currentMode = 'AP'; 
let rotateAngle = 0;
let processedBase64 = "";
let fileFlag = 0; 

function updateModeByValue(targetMode) {
    const validModes = ['AP', 'STA'];
    if (!validModes.includes(targetMode)) {
        console.warn('Invalid mode value. Using default AP mode.');
        targetMode = 'AP';
    }

    const activeButton = document.querySelector(`a[data-mode="${targetMode}"]`);
    if (activeButton) {
        modeButtons.forEach(btn => btn.classList.remove('active'));
        activeButton.classList.add('active');
        currentMode = targetMode;
        updateTips();
    }
}

function initializeMode() {
    updateModeByValue('AP');
}

function updateTips() {
    tips.forEach(tip => tip.classList.remove('d-none'));
    if (currentMode === "AP") {
        document.getElementById('tips-STA')?.classList.add('d-none');
    } else {
        document.getElementById('tips-AP')?.classList.add('d-none');
    }
}

function Even_init() {
    InPutButton = document.getElementById("Input_Button");
    SendButton = document.getElementById("Send_Button");
    FileInput = document.getElementById("File_Input");
    ImageSys = document.getElementById("Image_Input");
    RotateButton = document.getElementById("Rotate_Button");
    RotateButton.textContent = `Rotate: ${rotateAngle}°`;

    InPutButton.addEventListener("click", InPutButton_Even);
    FileInput.addEventListener("change", FileInput_Even);
    SendButton.addEventListener("click", SendButton_Even);
    RotateButton.addEventListener("click", RotateButton_Even);    

    ImageSys.onload = function () {
        const img = this;
        let targetW, targetH;
        if (img.naturalWidth > img.naturalHeight) {
            targetW = 800;
            targetH = 480;
        } else {
            targetW = 480;
            targetH = 800;
        }
        const canvas = document.createElement('canvas');
        canvas.width = targetW;
        canvas.height = targetH;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, targetW, targetH);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const palette = [
            [0, 0, 0],
            [255, 255, 255], 
            [255, 255, 0],
            [255, 0, 0], 
            null,
            [0, 0, 255], 
            [0, 255, 0]
        ];

        function findNearestColorIndex(r, g, b) {
            let minDist = Infinity, nearestIdx = 0;
            for (let i = 0; i < palette.length; i++) {
                if (palette[i] === null) continue;
                const pr = palette[i][0], pg = palette[i][1], pb = palette[i][2];
                const dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2;
                if (dist < minDist) {
                    minDist = dist;
                    nearestIdx = i;
                }
            }
            return nearestIdx;
        }
        const idxArr = new Uint8Array(canvas.width * canvas.height);
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const i = (y * canvas.width + x) * 4;
                const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];
                const idx = findNearestColorIndex(oldR, oldG, oldB);
                const [newR, newG, newB] = palette[idx];
                data[i] = newR;
                data[i + 1] = newG;
                data[i + 2] = newB;
                idxArr[y * canvas.width + x] = idx;
                const errR = oldR - newR;
                const errG = oldG - newG;
                const errB = oldB - newB;
                if (x + 1 < canvas.width) {
                    let j = i + 4;
                    data[j] = Math.max(0, Math.min(255, data[j] + errR * 7 / 16));
                    data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 7 / 16));
                    data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 7 / 16));
                }
                if (x > 0 && y + 1 < canvas.height) {
                    let j = i + (canvas.width - 1) * 4;
                    data[j] = Math.max(0, Math.min(255, data[j] + errR * 3 / 16));
                    data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 3 / 16));
                    data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 3 / 16));
                }
                if (y + 1 < canvas.height) {
                    let j = i + canvas.width * 4;
                    data[j] = Math.max(0, Math.min(255, data[j] + errR * 5 / 16));
                    data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 5 / 16));
                    data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 5 / 16));
                }
                if (x + 1 < canvas.width && y + 1 < canvas.height) {
                    let j = i + (canvas.width + 1) * 4;
                    data[j] = Math.max(0, Math.min(255, data[j] + errR * 1 / 16));
                    data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 1 / 16));
                    data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 1 / 16));
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);
        const processedImg = document.getElementById('Image_Processed');
        if (processedImg) {
            processedBase64 = canvas.toDataURL();
            processedImg.src = processedBase64;
        }
        window._lastImageIndexArray = idxArr;
    };
}

function InPutButton_Even() {
    FileInput.click();
}

function FileInput_Even(e) {
    fileFlag = 0;
    const file = e.target.files[0];
    if (!file) {
        alert("No file selected");
        return;
    }
    if (!file.type.startsWith("image/")) {
        alert("Please select an image file");
        return;
    }

    const url = URL.createObjectURL(file);
    ImageSys.src = url;
    ImageSys.addEventListener('load', function revoke() {
        URL.revokeObjectURL(url);
        ImageSys.removeEventListener('load', revoke);
    });
    fileFlag = 1;
    e.target.value = '';
}

function RotateButton_Even() {
    if (!fileFlag) {
        alert('No file selected');
        return;
    }
    rotateAngle += 90;
    if (rotateAngle > 270) rotateAngle = 0;
    RotateButton.textContent = `Rotate: ${rotateAngle}°`;
    if (!processedBase64) return;
    const processedImg = document.getElementById('Image_Processed');
    const img = new window.Image();
    img.onload = function () {
        let w = img.naturalWidth, h = img.naturalHeight;
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        if (rotateAngle % 180 === 0) {
            canvas.width = w;
            canvas.height = h;
        } else {
            canvas.width = h;
            canvas.height = w;
        }
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate((rotateAngle % 360) * Math.PI / 180);
        ctx.drawImage(img, -w / 2, -h / 2);
        ctx.restore();
        processedImg.src = canvas.toDataURL();
    };
    img.src = processedBase64;
}

function SendButton_Even() {
    let modeByte = 0;
    if (!fileFlag) {
        alert("Please select the picture file");
        return;
    }
    if (!processedBase64) return;

    if (currentMode === "STA") {
        modeByte = 1;
    } else {
        modeByte = 0;
    }

    const tempCanvas = document.createElement('canvas');
    const img = new window.Image();
    img.onload = function () {
        let w = img.naturalWidth, h = img.naturalHeight;
        if (rotateAngle % 180 === 0) {
            tempCanvas.width = w;
            tempCanvas.height = h;
        } else {
            tempCanvas.width = h;
            tempCanvas.height = w;
        }
        const ctx = tempCanvas.getContext('2d');
        ctx.save();
        ctx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
        ctx.rotate(rotateAngle * Math.PI / 180);
        ctx.drawImage(img, -w / 2, -h / 2);
        ctx.restore();

        const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const rgbaData = imageData.data;
        const width = tempCanvas.width;
        const height = tempCanvas.height;

        function createBMPUint8Array(imageData, width, height) {
            const bytesPerPixel = 3;
            const rowSize = Math.ceil((bytesPerPixel * width) / 4) * 4;
            const pixelDataSize = rowSize * height;
            const bmpFileHeaderSize = 14;
            const bmpInfoHeaderSize = 40;
            const totalBmpSize = bmpFileHeaderSize + bmpInfoHeaderSize + pixelDataSize;

            const bmpData = new Uint8Array(totalBmpSize);
            const dataView = new DataView(bmpData.buffer);

            dataView.setUint8(0, 0x42);
            dataView.setUint8(1, 0x4D);
            dataView.setUint32(2, totalBmpSize, true);
            dataView.setUint16(6, 0, true);
            dataView.setUint16(8, 0, true);
            dataView.setUint32(10, bmpFileHeaderSize + bmpInfoHeaderSize, true);

            dataView.setUint32(14, bmpInfoHeaderSize, true);
            dataView.setUint32(18, width, true);
            dataView.setUint32(22, height, true);
            dataView.setUint16(26, 1, true);
            dataView.setUint16(28, bytesPerPixel * 8, true);
            dataView.setUint32(30, 0, true);
            dataView.setUint32(34, pixelDataSize, true);
            dataView.setUint32(38, 72, true);
            dataView.setUint32(42, 72, true);
            dataView.setUint32(46, 0, true);
            dataView.setUint32(50, 0, true);

            let pixelOffset = bmpFileHeaderSize + bmpInfoHeaderSize;
            const rgba = imageData.data;

            for (let y = height - 1; y >= 0; y--) {
                let rowOffset = 0;
                for (let x = 0; x < width; x++) {
                    const rgbaIndex = (y * width + x) * 4;
                    const blue = rgba[rgbaIndex + 2];
                    const green = rgba[rgbaIndex + 1];
                    const red = rgba[rgbaIndex];

                    bmpData[pixelOffset + rowOffset] = blue;
                    bmpData[pixelOffset + rowOffset + 1] = green;
                    bmpData[pixelOffset + rowOffset + 2] = red;

                    rowOffset += bytesPerPixel;
                }
                while (rowOffset % 4 !== 0) {
                    bmpData[pixelOffset + rowOffset] = 0;
                    rowOffset++;
                }
                pixelOffset += rowSize;
            }

            return bmpData;
        }

        const pureBmpData = createBMPUint8Array(imageData, width, height);

        const totalDataSize = 1 + pureBmpData.length;
        const finalData = new Uint8Array(totalDataSize);
        finalData[0] = modeByte & 0xFF;
        finalData.set(pureBmpData, 1);

        const finalBlob = new Blob([finalData], { type: 'application/octet-stream' });

        fetch("/dataUP", {
            method: "POST",
            headers: { 
                "Content-Type": "application/octet-stream"
            },
            body: finalBlob
        })
        .then(res => {
            if (res.ok && res.status === 200) {
                return res.text().then(msg => {
                    alert('Upload successful!');
                });
            } else {
                return res.text().then(errorMsg => {
                    throw new Error(`Upload failed! ${res.status})${errorMsg ? `: ${errorMsg}` : ''}`);
                }).catch(() => {
                    throw new Error(`Upload failed! ${res.status})`);
                });
            }
        }).catch(err => {
            console.error("Upload error:", err);
            alert("Upload failed!");
        });
    };
    img.src = processedBase64;
}

function bindModeButtonEvents() {
    modeButtons.forEach(button => {
        button.addEventListener('click', function(event) {
            event.preventDefault();
            const targetMode = this.dataset.mode;
            updateModeByValue(targetMode); 
        });
    });
}

document.addEventListener('DOMContentLoaded', function() {
    modeButtons = document.querySelectorAll('a[data-mode]');
    tips = document.querySelectorAll('#tips > div');

    bindModeButtonEvents();

    Even_init();

    fetch('/NetWorkStatus')
        .then(response => {
            if (!response.ok) {
                throw new Error(`Request failed, status code:${response.status}`);
            }
            return response.text();
        })
        .then(data => {
            let serverMode = 'AP';
            const serverCode = parseInt(data);
            if (!isNaN(serverCode)) {
                serverMode = serverCode === 1 ? 'STA' : 'AP';
            }
            updateModeByValue(serverMode);
        })
        .catch(error => {
            console.error('Failed to obtain network status. Using default AP mode:', error);
            initializeMode();
        });
});